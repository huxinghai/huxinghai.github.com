<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: emberjs | Ka Ka Blog]]></title>
  <link href="http://huxinghai1988.github.com/blog/categories/emberjs/atom.xml" rel="self"/>
  <link href="http://huxinghai1988.github.com/"/>
  <updated>2016-02-21T11:58:01+08:00</updated>
  <id>http://huxinghai1988.github.com/</id>
  <author>
    <name><![CDATA[kaka]]></name>
    <email><![CDATA[huxinghai1988@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[emberjs2 自定义adapter方法与json序列化model]]></title>
    <link href="http://huxinghai1988.github.com/blog/2015/09/22/emberjsguide/"/>
    <updated>2015-09-22T21:50:00+08:00</updated>
    <id>http://huxinghai1988.github.com/blog/2015/09/22/emberjsguide</id>
    <content type="html"><![CDATA[<ol>
<li><p>自定义adapter请求服务器</p>

<p> 有时候model CURD 满足不了我们的需求，需要自己定义方法请求服务器，我们可以把这种方法定义adapter
代码如下：</p>

<pre><code>App.UserAdapter = App.ApplicationAdapter.extend({
  createRelation: function(opts){
    var url = [this.urlPrefix(), "users", "/pass"].join("/")
    return this.ajax(url, "POST", {data: opts})  
  }
})
</code></pre>

<p>controller调用</p>

<pre><code>var adapter = this.store.adapterFor("user");
adapter.createRelation({status: 1}).then(function(){
  // success
}, function(){
  // catch
})
</code></pre></li>
<li><p>json序列化model</p></li>
</ol>


<p>  <code>
  this.store.push(this.store.normalize("user", {id: 1, name: 'xxxxxxxxx'}))
 </code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[emberjs 2.0 遇到一个坑]]></title>
    <link href="http://huxinghai1988.github.com/blog/2015/09/12/emberjs-pit/"/>
    <updated>2015-09-12T11:52:00+08:00</updated>
    <id>http://huxinghai1988.github.com/blog/2015/09/12/emberjs-pit</id>
    <content type="html"><![CDATA[<p>最近项目使用emberjs 2.0版本，本身用2.0是比较纠结的事，由于之前就是只闻其术，不见其码，而且emberjs 1.x版本到2.0 做了一次无痛升级，之前用backbone框架感觉有些概念还是一样的，先说说用的emberjs 第一个坑贴代码。</p>

<p>```js
  //controller js 文件</p>

<p>  actions: {</p>

<pre><code>save: function(x){
  var tag = this.store.createRecord("tag", {name: this.get("newName")})

  tag.save().then(function(that){
    return function(){
      that.set("newName", "")
    }
  }(this), function(that){
    return function(r){
      tag.rolledBack()
      tag.unloadRecord()
      that.set("errors", r.errors)
    }
  }(this))
}
</code></pre>

<p>  }
```</p>

<p>tag 当我不管成功与失败template 多会加载这数据，我想在save失败不加载到template所以要加一个<strong>rolledBack</strong>和<strong>unloadRecord</strong>失败的时候就不加载了。</p>
]]></content>
  </entry>
  
</feed>
